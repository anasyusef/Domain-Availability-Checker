from DomainGenerators import DomainGenerator
import configuration
import logging
import namecheap
from bs4 import BeautifulSoup

# Logging configuration

logger = logging.getLogger(__name__)

logger.setLevel(logging.INFO)

formatter = logging.Formatter('%(levelname)s: %(asctime)s - File name: {} | TLD: {} - %(message)s'
                              .format(configuration.filename if configuration.domain_get_method ==
                                      'file' else configuration.domain_get_method,
                                      configuration.tld),
                              datefmt="%H:%M:%S")

file_handler = logging.FileHandler(configuration.log_filename)
file_handler.setLevel(logging.INFO)
file_handler.setFormatter(formatter)

logger.addHandler(file_handler)


class CheckDomain(DomainGenerator):
    checked = 0
    api = namecheap.Api(configuration.USERNAME, configuration.API_KEY, configuration.USERNAME, configuration.IP_ADDRESS,
                        sandbox=configuration.SANDBOX)

    url = "https://api.namecheap.com/xml.response?ApiUser={}&ApiKey={}&" \
          "UserName={}&ClientIP={}&Command=namecheap.users.getPricing&ProductType=DOMAIN&" \
          "ActionName=REGISTER".format(configuration.USERNAME, configuration.API_KEY, configuration.USERNAME,
                                       configuration.IP_ADDRESS)
    logger.info('Starting to get prices')
    # domain_prices = urlopen(url).read() # is better if it is cached
    soup = BeautifulSoup(open('prices.xml', 'r'), 'lxml')
    logger.info('Prices stored.')

    domains_to_check = 50

    function_requests_file = 0

    def check_domains_bulk(self, domains_list_found):

        """ Check domains generated by 'domains' and if there is any error for over-checking it will decrease the
        domains_to_check variable """

        CheckDomain.domains_to_check = 50

        if len(domains_list_found) <= CheckDomain.domains_to_check:
            CheckDomain.domains_to_check = len(domains_list_found)

        while True:
            try:
                logger.info('Requesting domain(s) availability. Currently data in VAR domains_to_check: {}'
                            .format(CheckDomain.domains_to_check))

                if CheckDomain.domains_to_check < 0:
                    return False

                return CheckDomain.api.domains_check(domains_list_found[:CheckDomain.domains_to_check])

            except namecheap.ApiError:

                logger.info('Error handled - namecheap.ApiError')

                CheckDomain.domains_to_check -= 10


    def add_domain_price(self, domains_dict_available):

        """  Gets dictionary of domain names looked in check_domains_bulk and check if they are available so further
         steps are proceeded, like getting price, if it is premium and so on."""

        domain_product_prices = CheckDomain.soup.find('product', {"name": configuration.tld[1:]})

        if domain_product_prices is not None:

            domain_price = domain_product_prices.findChildren()[0].attrs['price'] + \
                           domain_product_prices.findChildren()[0].attrs['currency']

            for domain, domain_info in domains_dict_available.items():

                if domains_dict_available[domain]['Premium'] is False:
                    domains_dict_available[domain]['Price'] = domain_price
                elif domains_dict_available[domain]['Premium'] is True:
                    logger.info('{} is premium'.format(domain))
                else:
                    logger.info('{} is not available'.format(domain))

            return domains_dict_available

        else:

            for domain, domain_info in domains_dict_available.items():

                if domains_dict_available[domain]['Premium'] is False:
                    domains_dict_available[domain]['Price'] = ''
                elif domains_dict_available[domain]['Premium'] is True:
                    logger.info('{} is premium'.format(domain))
                else:
                    logger.info('{} is not available'.format(domain))

            return domains_dict_available

    def remove_not_available(self, domains_dict_available):

        for domain, domain_info in list(domains_dict_available.items()):
            CheckDomain.checked += 1
            if domain_info['Available'] is False:
                del domains_dict_available[domain]

        return domains_dict_available

    def transfer_into_file(self, domains_dict_available):

        CheckDomain.function_requests_file += 1

        if CheckDomain.function_requests_file == 1:
            file = open(configuration.filename, 'w')
            logger.info('Writing headers into file')
            file.write('Domain,Premium,Price,Appraisal Value\n')
        else:
            file = open(configuration.filename, 'a')
            logger.info('Writing content into file')

        for domain, domain_info in domains_dict_available.items():

            file.write(domain + ',' + str(domain_info.get('Premium')) + ',' + domain_info.get('Price', 'Not found') +
                       ',' + domain_info.get('Appraisal', 'Not found').replace(',', '') + '\n')
            logger.info('{} domain info has been written!'.format(domain))

        file.close()

        logger.info('Finished writing')
